힙(heap) : 힙 성질(heap property) 만족하는 이진트리 

-------------------------------------------
표현법 1.
               a
       b             c
    X    d       e    f

H = [a, b, c, None, d, e, f]
H[0]의 왼쪽 자식 노드        : H[1]
H[0]의 오른쪽 자식 노드     : H[2]
H[2]의 왼쪽 자식 노드        : H[2*2+1] = H[5]
H[2]의 오른쪽 자식 노드     : H[2*2+2] = H[6]

H[k]의 왼쪽 자식 노드        : H[k*2 + 1]  --> 부모노드 H[k]
H[k]의 오른쪽 자식 노드     : H[k*2 + 2]  --> 부모노드 H[k]
H[k]의 부모 노드               : H[(k -1) //2] 

(장점) 상수시간의 연산으로 왼쪽, 오른쪽 자식과 부모노드를 알수 있다
(단점) 리프노드가 드문드문 있을 경우,none으로 메모리를 차지(낭비)하고 있다
-------------------------------------------
그래서, 각 레벨마다 꽉 채운 이진트리이고 힙 성질을 만족하면 힙이라하고...
그럼으로써 상수시간의 연산을 얻을수 있고 메모리 낭비를 줄일 수 있다 
-------------------------------------------
========================================
Heap 성질:
  - 모든 부모노드의 key 값은 자식 노드의 key 값보다 작지 않다
========================================


A = 2 8 6 1 10 15 3 12 11

(이진트리 표기)
                 2
        8                6
    1    10        15    3   ---> 이진트리이지만 힙 성질을 만족하지 않는다
12 11

--------------------------------
A = 15 12 6 11 10 2 3 1 5

                 15
         12            16
    11    10        2     3  --> 이진트리이고 힙 성질을 만족한다
   1  5

** 루트노드: 가장 큰값 A[0]
** 제공연산
     (1) insert                        : O(logn)
     (2) find-max : return A[0]  : O(1)
     (3) delete-max                : O(logn)

make-heap을 통해 이진트리를 heap으로 바꾸고 
제공 연산을 통해 삽입, 삭제 수행 
==============================

heap은 search 연산이 없다 --> 비효율적이기 때문
그래서, heap은 insert / find-max / delete-max가 빈번한 곳에 사용된다. 

max-heap과 같이 min-heap을 만들수도 있다 






